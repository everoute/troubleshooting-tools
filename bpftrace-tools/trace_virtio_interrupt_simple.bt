#!/usr/bin/bpftrace


tracepoint:irq:irq_handler_entry {
        $irq = args->irq;
        // get virtio queue interrupt range from /proc/interrupts, modify irq range 
        if ($irq >= 24 && $irq <= 63) {
                @irq_entry[$irq] = count();
        }
}

tracepoint:irq:irq_handler_exit {
        $irq = args->irq;
        // get virtio queue interrupt range from /proc/interrupts, modify irq range 
        if ($irq >= 24 && $irq <= 63) {
                @irq_exit_ret[$irq, args->ret] = count();
        }
}

// Track vring_interrupt calls
kprobe:vring_interrupt {
        @vring_interrupt_calls = count();
        @vring_interrupt_irq[arg0] = count();  // arg0 is the IRQ number
}

// Track vring_interrupt return values
kretprobe:vring_interrupt {
        @vring_interrupt_returns[retval] = count();
        // retval: IRQ_NONE=0, IRQ_HANDLED=1, IRQ_WAKE_THREAD=2
        if (retval == 0) {
                @vring_interrupt_ret_none = count();
        } else if (retval == 1) {
                @vring_interrupt_ret_handled = count();
        } else if (retval == 2) {
                @vring_interrupt_ret_wake_thread = count();
        }
}

interval:s:1 {
        time("%H:%M:%S \n");
        printf("Interrupt counts:\n");
        print(@irq_entry);
        printf("Interrupt handler return values:\n");
        print(@irq_exit_ret);
        
        printf("\nvring_interrupt statistics:\n");
        printf("  Total calls: ");
        print(@vring_interrupt_calls);
        printf("  Calls per IRQ:\n");
        print(@vring_interrupt_irq);
        printf("  Return values (raw):\n");
        print(@vring_interrupt_returns);
        printf("  IRQ_NONE (0): ");
        print(@vring_interrupt_ret_none);
        printf("  IRQ_HANDLED (1): ");
        print(@vring_interrupt_ret_handled);
        printf("  IRQ_WAKE_THREAD (2): ");
        print(@vring_interrupt_ret_wake_thread);
        
        clear(@irq_entry);
        clear(@irq_exit_ret);
        clear(@vring_interrupt_calls);
        clear(@vring_interrupt_irq);
        clear(@vring_interrupt_returns);
        clear(@vring_interrupt_ret_none);
        clear(@vring_interrupt_ret_handled);
        clear(@vring_interrupt_ret_wake_thread);
}

END {
        clear(@irq_entry);
        clear(@irq_exit_ret);
        clear(@vring_interrupt_calls);
        clear(@vring_interrupt_irq);
        clear(@vring_interrupt_returns);
        clear(@vring_interrupt_ret_none);
        clear(@vring_interrupt_ret_handled);
        clear(@vring_interrupt_ret_wake_thread);
}